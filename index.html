<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Three-Body Problem Simulation with HDR Background</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}

		#resetButton {
			position: absolute;
			top: 10px;
			left: 10px;
			z-index: 1;
			padding: 10px 20px;
			font-size: 16px;
			background-color: #fff;
			border: none;
			cursor: pointer;
		}
	</style>
</head>

<body>
	<button id="resetButton">Reset</button>
	<script type="importmap">
    {
        "imports": {
            "three": "./js/three.module.js",
            "three/addons/": "./js/addons/"
        }
    }
    </script>
	<script type="module">
		import * as THREE from 'three';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		const G = 1; // Gravitational constant
		const dt = 0.005; // Time step
		const max_points = 400; // Max points when rendering trail effect

		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		const renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.toneMapping = THREE.ACESFilmicToneMapping;
		renderer.toneMappingExposure = 1;
		renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Default shadow type
		document.body.appendChild(renderer.domElement);

		// Add lighting to the scene
		const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft white light
		scene.add(ambientLight);

		const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
		directionalLight.position.set(0, 5, 5); // Move the light closer to the front
		directionalLight.castShadow = true;
		directionalLight.shadow.mapSize.width = 1024;
		directionalLight.shadow.mapSize.height = 1024;
		directionalLight.shadow.camera.near = 0.1;
		directionalLight.shadow.camera.far = 50;
		scene.add(directionalLight);

		// Add a plane to receive shadows
		const planeGeometry = new THREE.PlaneGeometry(10, 10);
		const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
		const plane = new THREE.Mesh(planeGeometry, planeMaterial);
		plane.rotation.x = -Math.PI / 2;
		plane.position.y = -2;
		plane.receiveShadow = true;
		scene.add(plane);

		let bodies = [];
		let animationId;

		const textureLoader = new THREE.TextureLoader();
		const textures = [
			textureLoader.load('/textures/texture1.jpg'),
			textureLoader.load('/textures/texture2.jpg'),
			textureLoader.load('/textures/texture3.jpg'),
			textureLoader.load('/textures/texture4.jpg'),
			textureLoader.load('/textures/texture5.jpg'),
			textureLoader.load('/textures/texture6.jpg')
		];

		var controls = new OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;
		controls.dampingFactor = 0.05;

		// Load HDR texture
		new RGBELoader()
			.setPath('/textures/')
			.load('HDR_space.hdr', function (texture) {
				texture.mapping = THREE.EquirectangularReflectionMapping;
				scene.background = texture;
				scene.environment = texture;
				init();
				animate();
			});

		function createBody(texture) {
			const geometry = new THREE.SphereGeometry(0.2, 32, 32); // Increased the radius to 0.2
			const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ map: texture, normalMap: texture }));

			mesh.castShadow = true;
			mesh.receiveShadow = true;

			scene.add(mesh);

			const getRandomPosition = () => new THREE.Vector3(
				THREE.MathUtils.randFloatSpread(2),
				THREE.MathUtils.randFloatSpread(2),
				THREE.MathUtils.randFloatSpread(2)
			);

			const getRandomVelocity = () => new THREE.Vector3(
				THREE.MathUtils.randFloatSpread(0.1),
				THREE.MathUtils.randFloatSpread(0.1),
				THREE.MathUtils.randFloatSpread(0.1)
			);

			const getRandomWeight = () => THREE.MathUtils.randFloat(0.5, 2);

			// TRAIL EFFECT //
			// Set trail material
			var trail_mat = new THREE.LineBasicMaterial();
			trail_mat.color.setRGB(Math.random(), Math.random(), Math.random());
			trail_mat.flatShading = true;

			// Set trail geometry
			var trail_geometry = new THREE.BufferGeometry();
			var trace_array = new Array(max_points * 3).fill(0);
			trail_geometry.setAttribute("position", new THREE.Float32BufferAttribute(trace_array, 3));
			var drawCount = 0;
			var trail = new THREE.Line(trail_geometry, trail_mat);

			// Add trail mesh to the scene
			scene.add(trail);

			var body = {
				mesh: mesh,
				position: getRandomPosition(),
				velocity: getRandomVelocity(),
				weight: getRandomWeight(),
				radius: 0.2,
				rotationSpeed: new THREE.Vector3(Math.random() * 0.01, Math.random() * 0.01, Math.random() * 0.01),
				trace_array: trace_array,
				trail: trail_geometry,
				drawCount: drawCount
			};

			bodies.push(body);
		}

		function updateTrails() {
			for (const body of bodies) {
				body.trace_array.unshift(body.position.x, body.position.y, body.position.z);
				body.trace_array.splice(max_points * 3);
				body.trail.attributes.position.copyArray(body.trace_array);
				body.trail.attributes.position.needsUpdate = true;
				body.drawCount = THREE.MathUtils.clamp(body.drawCount, 0, max_points);
				body.trail.setDrawRange(0, body.drawCount);
				body.drawCount++;
			}
		}

		function createBodies() {

			bodies = [];

			createBody(textures[getRandomInt(0, textures.length)]);
			createBody(textures[getRandomInt(0, textures.length)]);
			createBody(textures[getRandomInt(0, textures.length)]);

			for (const body of bodies) {
				body.mesh.position.copy(body.position);
			}

			resetCamera();
		}

		function init() {
			createBodies();

			document.getElementById('resetButton').addEventListener('click', () => {
				cancelAnimationFrame(animationId);
				scene.clear();
				scene.add(ambientLight); // Re-add the lights after clearing the scene
				scene.add(directionalLight);
				scene.add(plane); // Re-add the plane after clearing the scene
				createBodies();
				animate();
			});
		}

		function computeForces() {
			for (let i = 0; i < bodies.length; i++) {
				let force = new THREE.Vector3(0, 0, 0);
				for (let j = 0; j < bodies.length; j++) {
					if (i !== j) {
						const direction = new THREE.Vector3().subVectors(bodies[j].position, bodies[i].position);
						const distance = Math.max(direction.length(), 0.1); // Avoid division by zero or extremely small distances
						if (distance < bodies[i].radius + bodies[j].radius) {
							// Collision detected, separate bodies
							const overlap = (bodies[i].radius + bodies[j].radius) - distance;
							direction.normalize();
							bodies[i].position.add(direction.multiplyScalar(-overlap / 2));
							bodies[j].position.add(direction.multiplyScalar(overlap / 2));
						} else {
							const f = G * bodies[i].weight * bodies[j].weight / (distance * distance);
							force.add(direction.normalize().multiplyScalar(f));
						}
					}
				}
				bodies[i].velocity.add(force.multiplyScalar(dt / bodies[i].weight));
			}
		}

		function updatePositions() {
			for (const body of bodies) {
				body.position.add(body.velocity.clone().multiplyScalar(dt));
				body.mesh.position.copy(body.position);

				// Rotate the bodies
				body.mesh.rotation.x += body.rotationSpeed.x;
				body.mesh.rotation.y += body.rotationSpeed.y;
				body.mesh.rotation.z += body.rotationSpeed.z;

				// Constrain the positions to stay within the screen
				body.position.clamp(new THREE.Vector3(-5, -5, -5), new THREE.Vector3(5, 5, 5));

				updateTrails();
			}
		}

		function animate() {
			animationId = requestAnimationFrame(animate);
			computeForces();
			updatePositions();
			controls.update();
			renderer.render(scene, camera);
		}

		function resetCamera() {
			camera.position.set(0, 0, 5);
			camera.rotation.set(0, 0, 0);
		}

		function getRandomInt(min, max) {
			const minCeiled = Math.ceil(min);
			const maxFloored = Math.floor(max);
			return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive
		}

	</script>
</body>

</html>